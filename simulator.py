r""" Exoplanet astrometry simulator

This module contains the simulator that computes the right ascension and
declination of an exoplanet given the orbital parameters and the epochs of
observation.

We use the orbit calculator from the `orbitize.kepler` module to do the
computations. The simulator is a callable class that takes in a tensor of
orbital parameters and returns a tensor of right ascension and declination
values.

"""

import torch
import numpy as np
from orbitize.kepler import calc_orbit

class Simulator:
    r""" Creates an orbit simulator

    Arguments:
        data_table (astropy.table.Table): Table containing the observations
            of the exoplanet. Must have columns "epoch", "quant1", "quant2",
            "quant1_err", and "quant2_err".
    """

    def __init__(self, data_table):
        
        self.data_table = data_table
        self.number_epochs = len(data_table)
        self.scale = 1e6

    def __call__(self, thetas: torch.Tensor) -> torch.Tensor:
        """
        Simulates observations of astronomical objects given a set of input parameters.

        Args:
            thetas (torch.Tensor): A tensor of shape (n_samples, 8) containing the input parameters for each sample.
                                    The 8 parameters are: sma, ecc, inc, aop, pan, tau, plx, mtot.

        Returns:
            torch.Tensor: A tensor of shape (n_samples, 2 * self.number_epochs) containing the simulated observations.
        """
        n_samples, _ = thetas.shape

        results = torch.empty((n_samples,
                               2 * self.number_epochs),
                               dtype=torch.float32)
        
        for i in range(n_samples):
            theta = thetas[i]
            sma, ecc, inc, aop, pan, tau, plx, mtot = theta.numpy()
            
            inc = np.radians(inc)
            aop = np.radians(aop)
            pan = np.radians(pan)
            
            ra, dec, _ = calc_orbit(
                self.data_table["epoch"], sma, ecc, inc, aop, pan,
                tau, plx, mtot, use_gpu = True, tau_ref_epoch=50000)

            # calc_orbit returns numpy arrays, need to convert to tensors
            ra = torch.tensor(ra,dtype=torch.float32)
            dec = torch.tensor(dec,dtype=torch.float32)

            # Adding Gaussian offets from observational uncertainties
            ra_err = self.data_table["quant1_err"]
            dec_err = self.data_table["quant2_err"]
            ra_err = np.random.normal(0, ra_err)
            dec_err = np.random.normal(0, dec_err)
        
            # Combine the RA and Dec values into a single tensor
            # x = [ra1, dec1, ra2, dec2, ...]
            result_tensor = torch.empty(2 * len(ra), dtype=torch.float32)
            result_tensor[0::2] = ra + ra_err
            result_tensor[1::2] = dec + dec_err
            results[i] = result_tensor

        results = self.process(results)

        return results

    def process(self, results: torch.Tensor) -> torch.Tensor:
        r""" Processes the results of the simulator

        Process the results of the simulator to make them more suitable for
        training.

        Arguments:
            results (torch.Tensor): Tensor of right ascension and declination
                values generated by the simulator. This tensor is of shape
                (n_samples, 2 * n_epochs).

        Returns:
            torch.Tensor: Tensor of processed results. This tensor is of shape
                (n_samples, 2 * n_epochs).
        """

        return results / self.scale